#!/usr/bin/env ruby

require "open3"
require "shellwords"

# Non-interactive commands — safe to capture all streams
def run(cmd)
  stdout, stderr, status = Open3.capture3(cmd)
  [stdout.chomp, stderr.chomp, status]
end

def run!(cmd)
  stdout, = run(cmd)
  stdout
end

def inside_tmux?
  ENV["TMUX"] && !ENV["TMUX"].empty?
end

def session_exists?(name)
  _, _, status = run("tmux has-session -t #{name} 2>/dev/null")
  status.success?
end

def repo_sessions
  sessions = run!("tmux list-sessions -F '\#{session_name}'").split("\n")
  sessions.each_with_object({}) do |s, hash|
    repo, _, status = run("tmux show-environment -t #{s} SESSION_REPO")
    next unless status.success?
    repo_dir = repo.sub(/^SESSION_REPO=/, "")
    hash[repo_dir] = s
  end
end

# Interactive commands — use backticks so gum/fzf can access the TTY

def pick_repo
  result = `(find ~/projects -mindepth 2 -maxdepth 2 -type d; find ~/src -mindepth 1 -maxdepth 1 -type d) | fzf --prompt="Pick repo: "`.chomp
  if result.empty?
    $stderr.puts "No repo selected."
    exit 1
  end
  result
end

def pick_repo_from_sessions
  existing = repo_sessions
  return pick_repo if existing.empty?

  repo_dirs = existing.keys
  labels = repo_dirs.map { |d| File.basename(d) }
  choices = labels + ["Other..."]
  selected = `echo '#{choices.join("\n")}' | gum filter --placeholder "Pick repo..."`.chomp
  return nil if selected.empty?

  if selected == "Other..."
    pick_repo
  else
    idx = labels.index(selected)
    idx ? repo_dirs[idx] : nil
  end
end

def list_branches(repo_dir)
  run!("git -C #{repo_dir} branch --list --format='%(refname:short)' 2>/dev/null").split("\n")
end

def list_worktrees(repo_dir)
  out = run!("git -C #{repo_dir} worktree list 2>/dev/null")
  worktrees = {}
  out.split("\n").each do |line|
    if line =~ /^(\S+)\s+\S+\s+\[(.+)\]$/
      worktrees[$2] = $1
    end
  end
  worktrees
end

def pick_branch(repo_dir)
  branches = list_branches(repo_dir)
  worktrees = list_worktrees(repo_dir)

  choices = ["New branch"] + branches
  selected = `echo '#{choices.join("\n")}' | gum filter --placeholder "Pick branch..."`.chomp
  return nil if selected.empty?

  if selected == "New branch"
    pick_new_branch(repo_dir, worktrees)
  else
    pick_existing_branch(repo_dir, selected, worktrees)
  end
end

def pick_new_branch(repo_dir, worktrees)
  branch = `gum input --header "Branch name:" --placeholder "my-feature"`.chomp
  return nil if branch.empty?

  base = prompt_base_branch(repo_dir)

  `gum confirm "Create git worktree?" --default=false`
  if $?.success?
    { type: :new_worktree, branch: branch, base: base }
  else
    { type: :new_branch_no_worktree, branch: branch, base: base }
  end
end

def pick_existing_branch(repo_dir, branch, worktrees)
  if worktrees.key?(branch)
    { type: :existing_worktree, dir: worktrees[branch] }
  else
    `gum confirm "Create worktree for '#{branch}'?" --default=false`
    if $?.success?
      { type: :existing_branch_new_worktree, branch: branch }
    else
      { type: :existing_branch_checkout, branch: branch }
    end
  end
end

def prompt_base_branch(repo_dir)
  current = run!("git -C #{repo_dir} rev-parse --abbrev-ref HEAD 2>/dev/null")
  current_label = current.empty? ? "current" : "current (#{current})"
  choice = `gum choose "Branch off main (default)" "Branch off #{current_label}"`.chomp
  choice.include?("current") ? :current : :main
end

def main_branch(repo_dir)
  ref = run!("git -C #{repo_dir} symbolic-ref --short refs/remotes/origin/HEAD 2>/dev/null")
  File.basename(ref.empty? ? "main" : ref)
end

def prompt_name_with_default(default)
  `gum input --header "Session name:" --value "#{default}"`.chomp
end

def default_session_name(repo_dir, result)
  case result[:type]
  when :existing_worktree
    File.basename(result[:dir])
  when :new_worktree, :existing_branch_new_worktree
    "#{File.basename(repo_dir)}-#{result[:branch]}"
  when :existing_branch_checkout, :new_branch_no_worktree
    result[:branch]
  end
end

def create_worktree(repo_dir, branch, base)
  parent = File.dirname(repo_dir)
  repo_name = File.basename(repo_dir)
  worktree_path = File.join(parent, "#{repo_name}-#{branch}")

  base_ref = case base
             when :main then "origin/#{main_branch(repo_dir)}"
             when :current then "HEAD"
             end

  _, err, status = run("git -C #{repo_dir} worktree add #{worktree_path} -b #{branch} #{base_ref}")
  unless status.success?
    $stderr.puts "Failed to create worktree: #{err}"
    exit 1
  end

  worktree_path
end

def create_worktree_for_existing_branch(repo_dir, branch)
  parent = File.dirname(repo_dir)
  repo_name = File.basename(repo_dir)
  worktree_path = File.join(parent, "#{repo_name}-#{branch}")

  _, err, status = run("git -C #{repo_dir} worktree add #{worktree_path} #{branch}")
  unless status.success?
    $stderr.puts "Failed to create worktree: #{err}"
    exit 1
  end

  worktree_path
end

def create_session(name, dir, repo_dir)
  run!("tmux new-session -d -s #{name} -n claude -c #{dir}")
  run!("tmux new-window -t #{name} -n nvim -c #{dir}")
  run!("tmux select-window -t #{name}:claude")

  run!("tmux send-keys -t #{name}:claude 'claude' Enter")
  run!("tmux send-keys -t #{name}:nvim 'nvim' Enter")

  run!("tmux set-environment -t #{name} SESSION_DIR #{dir}")
  run!("tmux set-environment -t #{name} SESSION_REPO #{repo_dir}")
end

def attach_session(name)
  if inside_tmux?
    exec("tmux switch-client -t #{name}")
  else
    exec("tmux attach-session -t #{name}")
  end
end

# --- Main ---

# Non-interactive setup mode (called by gum spin)
if ARGV[0] == "--setup"
  name = ARGV[1]
  repo_dir = ARGV[2]

  case ARGV[3]
  when "--new-worktree"
    branch = ARGV[4]
    base = ARGV[5] == "main" ? :main : :current
    dir = create_worktree(repo_dir, branch, base)
  when "--existing-branch-worktree"
    branch = ARGV[4]
    dir = create_worktree_for_existing_branch(repo_dir, branch)
  when "--use-dir"
    dir = ARGV[4]
  when "--checkout"
    branch = ARGV[4]
    run!("git -C #{repo_dir} checkout #{branch}")
    dir = repo_dir
  when "--new-branch"
    branch = ARGV[4]
    base = ARGV[5] == "main" ? :main : :current
    base_ref = case base
               when :main then "origin/#{main_branch(repo_dir)}"
               when :current then "HEAD"
               end
    run!("git -C #{repo_dir} checkout -b #{branch} #{base_ref}")
    dir = repo_dir
  else
    dir = repo_dir
  end

  create_session(name, dir, repo_dir)
  exit 0
end

# Quick attach if name given and session exists
if ARGV[0]
  name = ARGV[0]
  if session_exists?(name)
    puts "Session '#{name}' already exists. Switching to it."
    attach_session(name)
  end
end

# Step 1: Pick repo
repo_dir = pick_repo_from_sessions
if repo_dir.nil? || repo_dir.empty?
  $stderr.puts "Aborted."
  exit 1
end

# Step 2: Pick branch
result = pick_branch(repo_dir)
if result.nil?
  $stderr.puts "Aborted."
  exit 1
end

# Step 3: Pick session name
default_name = ARGV[0] || default_session_name(repo_dir, result)
name = prompt_name_with_default(default_name)
if name.nil? || name.empty?
  $stderr.puts "Aborted."
  exit 1
end

if session_exists?(name)
  puts "Session '#{name}' already exists. Switching to it."
  attach_session(name)
end

# Build setup command and run with spinner
setup_args = [Shellwords.escape(name), Shellwords.escape(repo_dir)]

case result[:type]
when :new_worktree
  setup_args += ["--new-worktree", Shellwords.escape(result[:branch]), Shellwords.escape(result[:base].to_s)]
when :existing_branch_new_worktree
  setup_args += ["--existing-branch-worktree", Shellwords.escape(result[:branch])]
when :existing_worktree
  setup_args += ["--use-dir", Shellwords.escape(result[:dir])]
when :existing_branch_checkout
  setup_args += ["--checkout", Shellwords.escape(result[:branch])]
when :new_branch_no_worktree
  setup_args += ["--new-branch", Shellwords.escape(result[:branch]), Shellwords.escape(result[:base].to_s)]
end

system("gum spin --title 'Setting up session...' -- workon --setup #{setup_args.join(" ")}")
unless $?.success?
  $stderr.puts "Setup failed."
  exit 1
end

attach_session(name)
